\section{Introduction}

\newpar Static analysis can aid in catching problems in programs early, allowing developers to find and fix errors before running their programs. The value of static analysis has been noticed by developers and is seeing adoption in the shape of recent smart linters, type and error checkers for dynamic languages, and is even being integrated directly into compilers as in the case with the GCC compiler in GGC version 10 \cite{gcc10}. GCC is the compiler of choice for a multitude of projects written in the C programming language, such as the Linux kernel development project. 

\newpar The Linux kernel supports a vast array of computer architectures and runs on a multitude of devices from embedded devices, through personal computers to large servers; on wireless access points, smart TVs, smartphones, refrigerators. Errors in the Linux kernel therefore affect a multitude of devices and can therefore have a potential significant negative impact.

\newpar An important aspect of kernel programming is management and manipulation of resources, be it devices, file handles, memory blocks, and locks. Shared-memory concurrency and locks are used extensively in the C source code of the Linux kernel in order to allow parallelization of subsystems within the kernel while at the same time avoiding race conditions. Static analysers allow detection of errors in the C source code of the Linux kernel by reasoning about this resource manipulation. A control flow graph can be found for the components of the kernel, which can then in turn be statically analysed to detect possible ressource manipulation errors. 

\newpar In this thesis I will try to answer the question: \textit{"How can bug checkers utilizing shape-and-effect inference with greater expressibility be defined using automata logic, how can such bug checkers be implemented as an extension to the Effective Bug Finding framework operating on the Linux kernel and how effective are such checker defintions?"}

\newpar This thesis will present the definition of \textit{monitor templates} and an implementation of such monitor templates as an extension of the work by Abal et. al. \cite{Abal2017EffectiveBF}. The implementation is incomplete, in that it detects some bugs, but not every bug. An incomplete tool which detects some but not all bugs in the source code under analysis is still of value to developers, since this could lead to detecting unknown programming errors --- detecting some bugs is beneficial compared to detecting no bugs. Such a tool should be fast, allowing quick detection and integration into deployment tools. The amount of time a tool takes to analyse a code base negatively impact developers' time and might therefore limit the adoption of the tool. Speed should hopefully therefore increase the use of the tool. 

\newpar This thesis is structured as follows. Section 2 details the necessary background knowledge required to define monitor templates based on the \textit{shape-and-effect} inference and related concepts defined by Abal et. al. Section 3 defines \textit{monitor templates}, how different types of bug checkers can be defined as monitor templates and show the correctness of this definition. Section 4 describes the implementation of monitor templates in practice both as a concrete algorithm and as an extension to the existing implementation of the EBA framework by Abal. et. al. Section 5 will evaluate the definition of monitor templates and the implementation of a monitor template bug checker. Finally, Section 6 will describe future work and possible extensions to this thesis.    