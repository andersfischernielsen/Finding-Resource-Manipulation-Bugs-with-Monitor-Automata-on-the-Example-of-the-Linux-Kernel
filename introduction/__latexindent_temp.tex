\section{Introduction}

\newpar Static analysis can aid in catching problems in programs early, allowing developers to find and fix errors before runtime. The value of static analysis has been noticed by developers and is seeing adoption in the shape of recent smart linters, type and error checkers for dynamic languages, and is even being integrated directly into compilers as in the case with the GCC compiler in version 10 \cite{gcc10}. GCC is the compiler of choice for a multitude of projects written in the C programming language, such as the Linux kernel development project. 

\newpar The Linux kernel supports a vast array of computer architectures and runs on a multitude of devices from embedded devices, through personal computers to large servers; on wireless access points, smart TVs, smartphones, refrigerators. Errors in the Linux kernel therefore affect a multitude of devices and can therefore have a potential significant negative impact.

\newpar An important aspect of kernel programming is management and manipulation of resources, be it devices, file handles, memory blocks, and locks. Shared-memory concurrency and locks are used extensively in the C source code of the Linux kernel in order to allow parallelization of subsystems within the kernel while at the same time avoiding race conditions. Static analysers allow detection of errors in the C source code of the Linux kernel by reasoning about this resource manipulation. A control flow graph can be found for the components of the kernel, which can then in turn be statically analysed to detect possible ressource manipulation errors. 

\newpar In this thesis I will answer the question: \textit{"How can bug checkers utilizing shape-and-effect inference be defined using finite automata with greater expressibility, how can such bug checkers be implemented as an extension to the Effective Bug Finding (EBA) framework operating on the Linux kernel and how effective are such checker definitions?"}

\newpar This thesis will present the definition of \textit{monitor templates} and an implementation of such monitor templates as an extension of the work by Abal et. al. \cite{Abal2017EffectiveBF}. The implementation is incomplete, in that it detects some bugs, but not every bug. An incomplete tool which detects some but not all bugs in the source code under analysis is still of value to developers, since this could lead to detecting unknown programming errors --- detecting some bugs is beneficial compared to detecting no bugs. Such a tool should be fast, allowing quick detection and integration into deployment tools. The amount of time a tool takes to analyse a code base negatively impacts developers' time and might therefore limit the adoption of the tool. Speed should hopefully therefore increase the use of the tool. 

\newpar The implementation is evaluated by comparing the detection rate of bugs on confirmed positives --- files which contain bugs reported by the Linux kernel developer community which have then been fixed --- by the implementation in this thesis versus the previous approach based on a subset of Computation Tree Logic (CTL). The previous approach shows limitations in how complex bug checkers can be expressed as well as detecting a small number of confirmed bugs. The expressiveness of monitor templates is also compared against the Computation Tree Logic subset definition of checkers in the previous work, in order to determine whether one approach allows expressing checkers which the other definition does not. The results of this show that monitor templates allow expressing more complex bug checkers with a higher detection rate in confirmed positives.   

\newpar This thesis is structured as follows. Section 2 details the necessary background knowledge required to define monitor templates based on the \textit{shape-and-effect} inference and related concepts defined by Abal et. al. Section 3 defines \textit{monitor templates}, how different types of bug checkers can be defined as monitor templates and shows the correctness of this definition. Section 4 describes the implementation of monitor templates in practice both as a concrete algorithm and as an extension to the existing implementation of the EBA framework by Abal. et. al. Section 5 will evaluate the definition of monitor templates and the implementation of a monitor template bug checker. Finally, Section 6 will describe future work and possible extensions to this thesis.    

\subsection{Related Work}
SMATCH by Engler et. al. \cite{smatch} defines \textit{meta-level compilation} which can be used to develop system-specific compiler extensions, to catch possible bugs in the Linux kernel and is in use by the Linux kernel developers presently. SDV, developed for Microsoft Inc., encodes API usage rules for kernel-level device drivers in the Windows operating system as state machines by specifying a state space as \textit{state variables} and \textit{events} as transitions between states, enabling the detection of bugs in the Windows kernel drivers \cite{SDV}. SDV uses SLAM, also developed by Microsoft Inc., as an analysis engine which has also been shown to detect kernel-level bugs in Windows \cite{SLAM}. Infer, developed for, and used by, Facebook and other companies, is a static analyzer based around symbolic execution and separation logic and is able to detect possible bugs in Java and C/C++/Objective-C code \cite{infer}.