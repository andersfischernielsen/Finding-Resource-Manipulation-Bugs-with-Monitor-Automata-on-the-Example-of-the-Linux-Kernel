\section{Introduction}

\newpar Static analysis can aid in catching problems in programs early, allowing developers to find and fix errors before running their programs. The value of static analysis has been noticed by developers and is seeing adoption in the shape of recent smart linters, type and error checkers for dynamic languages, and is even being integrated directly into compilers as in the case with the GCC compiler in GGC version 10 \cite{gcc10}. GCC is the compiler of choice for a multitude of projects written in the C programming language, such as the Linux kernel development project. 

\newpar The Linux kernel supports a vast array of computer architectures and runs on a multitude of devices from embedded devices, through personal computers to large servers; on wireless access points, smart TVs, smartphones, refrigerators. Errors in the Linux kernel therefore affect a multitude of devices and can therefore have a potential significant negative impact.

\newpar An important aspect of kernel programming is management and manipulation of resources, be it devices, file handles, memory blocks, and locks. Shared-memory concurrency and locks are used extensively in the C source code of the Linux kernel in order to allow parallelization of subsystems within the kernel while at the same time avoiding race conditions. Static analysers allow detection of errors in the C source code of the Linux kernel by reasoning about this resource manipulation. A control flow graph can be found for the components of the kernel, which can then in turn be statically analysed to detect possible ressource manipulation errors. 

\newpar This thesis will present the definition of \textit{monitor templates} and an implementation of such monitor templates as an extension of the work by Abal et. al. \cite{Abal2017EffectiveBF}. The implementation is incomplete, in that it detects some bugs, but not every bug. An incomplete tool which detects some but not all bugs in the source code under analysis is still of value to developers, since this could lead to detecting unknown programming errors --- detecting some bugs is beneficial compared to detecting no bugs. Such a tool should be fast, allowing quick detection and integration into deployment tools. The amount of time a tool takes to analyse a code base negatively impact developers' time and might therefore limit the adoption of the tool. Speed should hopefully therefore increase the use of the tool. 
