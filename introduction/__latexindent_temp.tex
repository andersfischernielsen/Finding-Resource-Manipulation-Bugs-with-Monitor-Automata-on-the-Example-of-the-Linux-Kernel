\section{Introduction}

\newpar Static analysis can aid in catching problems in programs early, allowing developers to find and fix errors before running their programs. The value of static analysis has been noticed by developers and is seeing adoption in the shape of recent smart linters, type and error checkers for dynamic languages, and is even being integrated directly into compilers as in the case with the GCC compiler in GGC version 10 \todo{cite GNU GCC 10 website}. GCC is the compiler of choice for a multitude of projects written in the C programming language, such as the Linux kernel development project. 

\newpar The Linux kernel supports a vast array of computer architectures and runs on a multitude of devices from embedded devices, through personal computers to large servers; on wireless
access points, smart TVs, smartphones, refrigerators.
Errors in the Linux kernel therefore affect a multitude of devices and can therefore have a potential significant negative impact.

\newpar An important aspect of kernel programming is management and manipulation of resources, be it devices, file handles, memory blocks, and locks. Shared-memory concurrency and locks are used extensively in the C source code of the Linux kernel in order to allow parallelization of subsystems within the kernel while at the same time avoiding race conditions. Static analysers allow detection of errors in the C source code of the Linux kernel by reasoning about this resource manipulation. A control flow graph can be found for the components of the kernel, which can then in turn be statically analysed to detect possible ressource manipulation errors.

\cite{unlockPOSIX}
