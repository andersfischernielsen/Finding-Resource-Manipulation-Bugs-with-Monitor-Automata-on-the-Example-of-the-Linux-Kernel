\section{Evaluation}

\subsection{Expressiveness}

In the implementation of the Computation Tree Logic (CTL) bug checker specifications by Abal et. al., the checkers implement four predicates, forming the CTL formula of the shape $a\;\text{EU}\;(b\;\land\;EX\;(c\;\text{EU}\;d))$ \cite{Abal2017EffectiveBF}\cite{research-project}. This formula can also be written as $E\;a\;\text{U}\;(b\;\land\;EX\;(E\;c\;\text{U}\;d))$. This limits the expressiveness of checks which can be defined, given that the logic for detecting bugs must be implemented within these four functions $a$, $b$, $c$ and $d$. Specifying the checkers as monitor templates therefore allows for greater expressiveness in the checker definition. To illustrate this, Figure \ref{expressive-monitor} below shows a monitor template definition which cannot be defined in the existing CTL implementation of the EBA framework because there is no way to express the circular alternation.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{evaluation/figures/monitor}
    \caption{An illustration of a monitor template which cannot be expressed by the CTL formula $a\;\text{EU}\;(b\;\land\;EX\;(c\;\text{EU}\;d))$.}
    \label{expressive-monitor}
\end{figure}

\newpar Another example of a structure that the CTL formulation cannot model is a very long sequence of given effects, e.g. an unlock and a lock repeatedly, followed by a final effect. This can be modelled using a monitor template defined as a loop between effects, going to the accepting state on the final effect. This is illustrated in Figure \ref{long-monitor}. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.35\textwidth]{evaluation/figures/long-monitor}
    \caption{An illustration of a monitor template which cannot be expressed by the CTL formula $a\;\text{EU}\;(b\;\land\;EX\;(c\;\text{EU}\;d))$.}
    \label{long-monitor}
\end{figure}

\newpar On the other hand, the CTL formula $a\;\text{EU}\;(b\;\land\;EX\;(c\;\text{EU}\;d))$ \textit{can} be expressed as a monitor template, as seen in Figure \ref{ctl-as-monitor}. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.35\textwidth]{evaluation/figures/ctl-as-monitor}
    \caption{An illustration of a monitor template equivalent to the CTL formula $a\;\text{EU}\;b\;\text{X}(c\;\text{EU}\;d)$.}
    \label{ctl-as-monitor}
\end{figure}

\newpar This expressiveness allows specifying the CTL checkers defined in the work by Abal et. al and also possible future more granular checkers, in other words increasing the posibilities of extending the EBA framework. Certain bug types can show themselves in different code constructions, such as a double-unlock bug being defined as both an unlock happening before any locks happening and explicit double-unlocks. The expressiveness of monitor templates allows specifying multiple types of behaviour in the code under analysis for a single bug type as more complex transition function in order to increase the precision of checks.

\subsection{Accuracy}

Experimental static analysis has recently been added to the GCC compiler chain \cite{gcc10}, allowing developers to run check for double-free bugs in their code. David Malcolm --- the developer of the static analysis released in GCC 10 --- has described his challenges in reducing the amount of false positives during the development of the analysis \cite{gcc10-development}, showing that reducing these proves to be a difficult problem. Reducing false positives is important, since developers might avoid using a tool if they see false output too often. The developer of the popular \texttt{curl} command-line tool confirms this, noting that the addition of the analysis in GCC 10 is appreciated, but that it still produces too many false positives to be usable. \cite{curl-static-analysis}. Reducing the amount of false positives in the implementation of monitor templates has been difficult, since a tradeoff between the ability to detect more bugs and reducing the amount of false positives has to be made. In other words, increasing precision is hard. We see that the actual bugs are present, but false positives are also reported. 

\newpar The implementation has been evaluated by assembling a set of patched double-unlock bugs found in the Linux kernel source control, \textit{git}. Kernel developers submit patches as \textit{commits}, containing an message explaining what the patch addresses. These messages have been explored in search of the phrase \textit{"double unlock"}, resulting in 16 matching patches. These patches can be seen in Table \ref{evaluation-table}. These patches can be \textit{checked out} using git, in turn reverting the source code repository to the state where the patch was submitted. The source code repository can then be rolled back further to the commit just prior to the patch, in turn reverting the repository to a state where the bug is present. Once this has been done, the file under analysis can be compiled and analysed by the EBA framework with the implementation of the double-unlock checker. 

\newpar This process has been automated using the Docker tool in order to evaluate tests in a reproducable manner \cite{docker}. A base Linux Docker \textit{image} is used to provide the required Linux libraries for compilation and files are then compiled and extracted from this Docker image for analysis by EBA with and without the extensions described in this thesis. The results of analysis using the previous approach and my approach are then stored in text files for easy comparison for each file under analysis. 

\begin{table}[H]
    \centering
    \setlength{\tabcolsep}{5pt}
    \renewcommand{\arraystretch}{1.25}
    \scriptsize
    \begin{tabular}{lllll}
    \textbf{Linux Kernel File}                    & \textbf{Present in}          & \textbf{My Approach}  & \textbf{Previous Approach} & \textbf{Patched in} \\
    \hline
    drivers/block/drbd/drbd\_main.c               & \texttt{b0814361}            & Detected              & Not detected               & \texttt{8e9c5230}            \\
    fs/ubifs/orphan.c                             & \texttt{7542c6de}            & Detected              & Detected                   & \texttt{4dd75b33}            \\
    drivers/gpu/drm/nouveau/nouveau\_svm.c        & \texttt{5fbcf501}            & Not detected          & Not detected               & \texttt{de4ee728}            \\
    fs/btrfs/file.c                               & \texttt{78e03651}            & Not detected          & Not detected               & \texttt{f49aa1de}            \\
    drivers/staging/wilc1000/wilc\_wlan.c         & \texttt{ca641bae}            & Not detected          & Not detected               & \texttt{fea69916}            \\
    drivers/staging/kpc2000/kpc\_dma/fileops.c    & \texttt{d4c596eb}            & Not detected          & Not detected               & \texttt{c85aa326}            \\
    fs/nfs/client.c                               & \texttt{a46126cc}            & Not detected          & Not detected               & \texttt{c260121a}            \\
    fs/btrfs/file.c                               & \texttt{2b90883c}            & Not detected          & Not detected               & \texttt{8fca9550}            \\
    drivers/media/dvb-core/dvbdev.c               & \texttt{ded71626}            & Internal error        & Internal error             & \texttt{122d0e8d}            \\
    mm/memory\_hotplug.c                          & \texttt{6376360e}            & Not detected          & Not detected               & \texttt{e3df4c6e}            \\
    sound/soc/codecs/pcm512x.c                    & \texttt{fd270fca}            & Not detected          & Not detected               & \texttt{28b698b7}            \\
    drivers/target/target\_core\_user.c           & \texttt{807cf197}            & Not detected          & Not detected               & \texttt{f0e89aae}            \\
    drivers/rpmsg/qcom\_smd.c                     & \texttt{fb416f69}            & Internal error        & Internal error             & \texttt{c3388a07}            \\
    drivers/scsi/aacraid/commsup.c                & \texttt{09624645}            & Not detected          & Not detected               & \texttt{d844752e}            \\
    drivers/staging/rtl8188eu/os\_dep/usb\_intf.c & \texttt{612e1c94}            & Compile error         & Compile error              & \texttt{23bf4042}            \\
    block/blk-cgroup.c                            & \texttt{e0223003}            & Compile error         & Compile error              & \texttt{bbb427e3}  
    \end{tabular}
    \caption{The results of comparing the previous CTL-based approach to my monitor-template-based approach.}
    \label{evaluation-table}
\end{table}

\newpar The files \texttt{drbd\_main.c} and \texttt{orphan.c} are successfully detected. Both of these files have a double-unlock in an if-statement which, when true, result in a double-unlock bug. In the case of the file \texttt{drbd\_main.c} by the use of mutexes, by a spin-unlock in the file \texttt{orphan.c}. 

\newpar The files \texttt{nouveau\_svm.c}, \texttt{fileops.c}, \texttt{file.c} and \texttt{memory\_hotplug.c} are not detected by either approach. These files exhibit a double-unlock bug when certain error codes are reported during execution, but unlocking happens by the use of an external function and is therefore not detected as an unlock by EBA. The file \texttt{wilc\_wlan.c} also contains a bug due to the use of an external unlock function, again not detected as an unlock by EBA, which was executed twice in succession under certain conditions.

\newpar The files \texttt{pcm512x.c} and \texttt{target\_core\_user.c} contain double mutex unlocks similar to \texttt{drbd\_main.c}, but these bugs are within static functions and are therefore ignored. The files \texttt{qcom\_smd.c} and \texttt{commsup.c} unlock using goto-statements, either resulting in EBA giving an internal error or not detecting the unlocks. 

\newpar EBA raises a stack overflow error on the file \texttt{dvbdev.c} and the remainder of the files \texttt{usb\_intf.c} and \texttt{blk-cgroup.c} fail to compile. A few reported positives in e.g. the file \texttt{commsup.c} seem like actual undiscovered double-unlock bugs, but given the complexity of the code under analysis I have been unable to verify whether these are in fact false positives or actual bugs. 

\newpar Remaining false positives are mainly reported in when an unlock is detected before the region the unlock happens on has been locked, as per the POSIX defintion of a double-unlock \cite{unlockPOSIX}. This is an unfortunate effect of the single-file analysis of EBA. Memory regions can have been unlocked elsewhere than the code under analysis if the file being analyses is part of a module consisting of several files. 

\newpar This evaluation has allowed me to answer part of my research question \textit{"How effective are such [monitor template] checker definitions?"}. The accuracy of the implementation of a double-unlock bug checker using monitor templates is higher than the previous approach. It is furthermore possible to express more complex bug checkers using monitor templates compared to the CTL-based checker implementation, giving greater expressibility. In summary; though not all confirmed bugs are detected, a higher accuracy is observed when using monitor templates and monitor templates allow for greater expressibility when defining bug checkers. 